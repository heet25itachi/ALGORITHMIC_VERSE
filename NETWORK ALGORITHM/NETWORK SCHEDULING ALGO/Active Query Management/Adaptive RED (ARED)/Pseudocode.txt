FUNCTION ared_enqueue(queue, packet, min_th, max_th, w_q, target, alpha, beta, interval, capacity)
    // Update average queue length
    IF queue is empty THEN
        avg = 0
    ELSE
        avg = (1 - w_q) * avg + w_q * queue.length
    END IF

    // Adjust max_p every interval
    IF CURRENT_TIME - last_update >= interval THEN
        IF avg > target AND max_p <= 0.5 THEN
            max_p = max_p * (1 + alpha)
        ELSE IF avg < target AND max_p >= 0.01 THEN
            max_p = max_p * beta
        END IF
        last_update = CURRENT_TIME
    END IF

    // Decide whether to drop packet
    IF avg < min_th THEN
        drop = false
    ELSE IF avg >= max_th THEN
        drop = true
    ELSE
        pb = max_p * (avg - min_th) / (max_th - min_th)
        pa = pb / (1 - count * pb)
        IF random(0, 1) < pa THEN
            drop = true
        ELSE
            drop = false
        END IF
        count = count + 1
    END IF

    IF drop THEN
        PRINT "Packet dropped, size: ", packet.size, ", avg queue length: ", avg, ", max_p: ", max_p
        RETURN false
    ELSE IF queue.length < capacity THEN
        queue.enqueue(packet)
        PRINT "Packet enqueued, size: ", packet.size, ", avg queue length: ", avg, ", max_p: ", max_p
        count = 0
        RETURN true
    ELSE
        PRINT "Queue full, packet dropped, size: ", packet.size
        RETURN false
    END IF
END FUNCTION

FUNCTION simulate_ared(packets, min_th, max_th, w_q, target, alpha, beta, interval, capacity)
    queue = EMPTY QUEUE
    avg = 0
    count = 0
    max_p = 0.1
    last_update = 0
    dropped = 0
    PRINT "Initial queue: empty"

    FOR EACH packet IN packets
        IF ared_enqueue(queue, packet, min_th, max_th, w_q, target, alpha, beta, interval, capacity) THEN
            // Packet enqueued
        ELSE
            dropped = dropped + 1
        END IF
    END FOR

    PRINT "Final queue length: ", queue.length
    PRINT "Packets dropped: ", dropped
    PRINT "Final queue: ", queue
END FUNCTION
