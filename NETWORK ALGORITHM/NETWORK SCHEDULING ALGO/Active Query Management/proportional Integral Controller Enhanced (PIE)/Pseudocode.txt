// Packet structure: {size, arrival_time}
// Queue structure: array or list with capacity, front, rear pointers

FUNCTION create_queue(capacity)
    RETURN Queue with capacity, empty items, front = 0, rear = -1, length = 0
END FUNCTION

FUNCTION enqueue(queue, packet)
    IF queue.length >= queue.capacity THEN
        PRINT "Queue full, packet dropped, size: ", packet.size
        RETURN false
    END IF
    queue.rear = (queue.rear + 1) mod queue.capacity
    queue.items[queue.rear] = packet
    queue.length = queue.length + 1
    PRINT "Packet enqueued, size: ", packet.size, ", queue delay: ", delay, ", drop prob: ", drop_prob
    RETURN true
END FUNCTION

FUNCTION dequeue(queue)
    IF queue.length = 0 THEN
        RETURN null
    END IF
    packet = queue.items[queue.front]
    queue.front = (queue.front + 1) mod queue.capacity
    queue.length = queue.length - 1
    RETURN packet
END FUNCTION

FUNCTION peek(queue)
    IF queue.length = 0 THEN
        RETURN null
    END IF
    RETURN queue.items[queue.front]
END FUNCTION

FUNCTION simulate_pie(packets, target, update_interval, alpha, beta, max_drop_prob, max_burst, capacity)
    queue = create_queue(capacity)
    current_time = 0
    last_update = 0
    drop_prob = 0
    prev_delay = 0
    burst_time = max_burst
    dropped = 0
    PRINT "Initial queue: empty"

    FOR EACH packet IN packets
        packet.arrival_time = current_time
        delay = IF queue.length = 0 THEN 0 ELSE current_time - peek(queue).arrival_time

        // Update drop probability every update_interval
        IF current_time - last_update >= update_interval THEN
            error = delay - target
            drop_prob = drop_prob + alpha * error + beta * (delay - prev_delay)
            drop_prob = MAX(0, MIN(max_drop_prob, drop_prob))
            prev_delay = delay
            last_update = current_time
            IF delay > target THEN
                burst_time = 0
            ELSE IF burst_time < max_burst THEN
                burst_time = burst_time + update_interval
            END IF
        END IF

        // Decide whether to drop packet
        drop = burst_time < max_burst AND delay > target AND random(0,1) < drop_prob

        IF drop THEN
            PRINT "Packet dropped, size: ", packet.size, ", queue delay: ", delay, ", drop prob: ", drop_prob
            dropped = dropped + 1
        ELSE IF enqueue(queue, packet) THEN
            dequeued_packet = dequeue(queue)
            PRINT "Packet dequeued, size: ", dequeued_packet.size, ", queue delay: ", delay
        ELSE
            dropped = dropped + 1
        END IF
        current_time = current_time + 1
    END FOR

    WHILE queue.length > 0
        delay = current_time - peek(queue).arrival_time
        IF current_time - last_update >= update_interval THEN
            error = delay - target
            drop_prob = drop_prob + alpha * error + beta * (delay - prev_delay)
            drop_prob = MAX(0, MIN(max_drop_prob, drop_prob))
            prev_delay = delay
            last_update = current_time
            IF delay > target THEN
                burst_time = 0
            ELSE IF burst_time < max_burst THEN
                burst_time = burst_time + update_interval
            END IF
        END IF
        dequeued_packet = dequeue(queue)
        PRINT "Packet dequeued, size: ", dequeued_packet.size, ", queue delay: ", delay
        current_time = current_time + 1
    END WHILE

    PRINT "Final queue length: ", queue.length
    PRINT "Packets dropped: ", dropped
    PRINT "Final queue: empty"
END FUNCTION

// Main
packets = array of 200 packets with random sizes (1â€“100)
simulate_pie(packets, target = 15, update_interval = 30, alpha = 0.125, beta = 1.25, max_drop_prob = 0.1, max_burst = 150, capacity = 100)


