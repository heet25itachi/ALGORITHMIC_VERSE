// Helper function: Quicksort for small arrays
FUNCTION quicksort(arr, left, right)
    IF left >= right THEN
        RETURN
    END IF
    pivot = arr[right]
    i = left
    j = right
    WHILE i < j
        WHILE i < j AND arr[i] <= pivot
            i = i + 1
        END WHILE
        WHILE i < j AND arr[j] > pivot
            j = j - 1
        END WHILE
        IF i < j THEN
            SWAP arr[i], arr[j]
        END IF
    END WHILE
    SWAP arr[right], arr[i]
    quicksort(arr, left, i - 1)
    quicksort(arr, i + 1, right)
END FUNCTION

// Helper function: k-merger to merge k sorted sequences
FUNCTION k_merger(inputs, input_sizes, k, buffer, buffer_size, k3)
    // Base case: single input
    IF k = 1 THEN
        size = MIN(input_sizes[0], k3)
        output = inputs[0][0 .. size - 1]
        inputs[0] = inputs[0][size .. input_sizes[0] - 1]
        input_sizes[0] = input_sizes[0] - size
        RETURN output
    END IF

    // Recursive case
    sqrt_k = FLOOR(SQRT(k))
    input_mergers = ARRAY of size sqrt_k
    input_merger_sizes = ARRAY of size sqrt_k
    sub_buffers = ARRAY of sqrt_k arrays, each of size buffer_size
    sub_buffer_sizes = ARRAY of size sqrt_k, initialized to 0
    k32 = FLOOR(k ^ 1.5)

    // Initialize input mergers
    FOR i = 0 TO sqrt_k - 1
        input_mergers[i] = inputs[i * sqrt_k]
        input_merger_sizes[i] = input_sizes[i * sqrt_k]
    END FOR

    // Fill sub-buffers if less than k^(3/2) elements
    FOR i = 0 TO sqrt_k - 1
        IF sub_buffer_sizes[i] < k32 THEN
            temp_output = k_merger(input_mergers, input_merger_sizes, sqrt_k, sub_buffers[i], buffer_size, k32)
            sub_buffers[i][0 .. LENGTH(temp_output) - 1] = temp_output
            sub_buffer_sizes[i] = LENGTH(temp_output)
        END IF
    END FOR

    // Merge sub-buffers using output merger
    output_merger_inputs = sub_buffers
    output_merger_sizes = sub_buffer_sizes
    output = k_merger(output_merger_inputs, output_merger_sizes, sqrt_k, buffer, buffer_size, k3)

    // Update sub-buffers
    FOR i = 0 TO sqrt_k - 1
        sub_buffers[i] = sub_buffers[i][LENGTH(output) .. sub_buffer_sizes[i] - 1]
        sub_buffer_sizes[i] = sub_buffer_sizes[i] - LENGTH(output)
    END FOR

    RETURN output
END FUNCTION

// Main Funnelsort function
FUNCTION funnelsort(arr, n, z, l)
    IF n <= z THEN
        quicksort(arr, 0, n - 1)
        RETURN
    END IF

    // Split into k subarrays
    k = CEIL(n ^ (1/3))
    sub_size = CEIL(n / k)
    subarrays = ARRAY of k arrays
    subarray_sizes = ARRAY of size k

    PRINT "Sorted subarrays:"
    FOR i = 0 TO k - 1
        size = IF i = k - 1 THEN n - i * sub_size ELSE sub_size
        subarrays[i] = arr[i * sub_size .. i * sub_size + size - 1]
        subarray_sizes[i] = size
        quicksort(subarrays[i], 0, size - 1)
        PRINT "Subarray ", i, ": ", subarrays[i][0 .. size - 1]
    END FOR

    // Merge using k-merger
    buffer_size = 2 * FLOOR(k ^ 1.5)
    buffer = ARRAY of size buffer_size, initialized to 0
    output = k_merger(subarrays, subarray_sizes, k, buffer, buffer_size, n)

    // Copy output back to arr
    FOR i = 0 TO n - 1
        arr[i] = output[i]
    END FOR
END FUNCTION

// Main program to test the algorithm
MAIN
    arr = [64, 34, 25, 12, 22, 11, 90, 87, 45, 67, 23, 43, 56, 78, 91, 13]
    n = 16
    z = 8  // Cache size
    l = 2  // Cache line size

    PRINT "Initial array: ", arr[0 .. n - 1]

    funnelsort(arr, n, z, l)

    PRINT "Sorted array: ", arr[0 .. n - 1]
END MAIN




## Notes on Pseudocode ##

Purpose: Sorts an array of $ N $ elements using the cache-oblivious Funnelsort algorithm, optimizing memory transfers with complexity $ O\left(\frac{N}{L}\log_Z N\right) $ and runtime $ \Theta(N \log N) $.
Algorithm Details:

Split: Divides the array into $ k = \lceil N^{1/3} \rceil $ subarrays of size $ \lceil N/k \rceil $, sorting each recursively using quicksort.
Merge: Uses a $ k $-merger to merge $ k $ sorted subarrays, outputting all $ N $ elements in one invocation.
k-merger: Recursively merges $ k $ sorted sequences using $ \sqrt{k} $ input mergers, each handling $ \sqrt{k} $ inputs, and $ \sqrt{k} $ buffers of size $ 2k^{3/2} $. The output merger combines buffer outputs.
Buffer Management: Simulates circular queues as arrays, filling buffers only when they have fewer than $ k^{3/2} $ elements.


Test Case:

Input Array: $ [64, 34, 25, 12, 22, 11, 90, 87, 45, 67, 23, 43, 56, 78, 91, 13] $, $ N = 16 $.
Parameters:

$ k = \lceil 16^{1/3} \rceil \approx \lceil 2.52 \rceil = 3 $.
Subarray sizes: $ \lceil 16/3 \rceil \approx 5 $ or 6 (e.g., 5, 5, 6).
$ Z = 8 $ (cache size, elements), $ L = 2 $ (cache line size, elements).
Buffer size: $ 2k^{3/2} = 2 \cdot 3^{1.5} \approx 10 $.


Output:

Initial array: $ [64, 34, 25, 12, 22, 11, 90, 87, 45, 67, 23, 43, 56, 78, 91, 13] $.
Subarrays: e.g., $ [12, 22, 25, 34, 64] $, $ [11, 45, 67, 87, 90] $, $ [13, 23, 43, 56, 78, 91] $.
Sorted array: $ [11, 12, 13, 22, 23, 25, 34, 43, 45, 56, 64, 67, 78, 87, 90, 91] $.




Constraints:

Comparison-based sorting for non-negative integers.
Simulates cache-oblivious behavior in-memory (no actual cache management).
Uses quicksort for recursive sorting of subarrays when $ n \leq Z $.
