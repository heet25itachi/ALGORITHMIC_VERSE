// Constants
weekdays = ["Noneday", "Oneday", "Twosday", "Treblesday", "Foursday", "Fiveday", "Six-a-day"] // Sunday=0, ..., Saturday=6
month_names = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
doomsday_dates = [[3, 4], [28, 29], [14, 14], [4, 4], [9, 9], [6, 6], [11, 11], [8, 8], [5, 5], [10, 10], [7, 7], [12, 12]] // [common, leap] for Jan/Feb
month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

// Function to check if a year is a leap year
FUNCTION is_leap_year(year)
    RETURN (year MOD 4 = 0 AND (year MOD 100 ≠ 0 OR year MOD 400 = 0))
END FUNCTION

// Function to validate date
FUNCTION is_valid_date(day, month, year)
    IF month < 1 OR month > 12 OR day < 1 OR year < 1583 THEN
        RETURN FALSE
    END IF
    max_days = month_days[month - 1]
    IF month = 2 AND is_leap_year(year) THEN
        max_days = 29
    END IF
    RETURN day ≤ max_days
END FUNCTION

// Function to calculate the year's doomsday
FUNCTION get_doomsday(year)
    c = FLOOR(year / 100) // Century
    y = year MOD 100 // Last two digits
    anchor = (5 * (c MOD 4) + 2) MOD 7 // Tuesday = 2
    a = FLOOR(y / 12)
    b = y MOD 12
    c_y = FLOOR(b / 4)
    RETURN (anchor + a + b + c_y) MOD 7
END FUNCTION

// Function to get the day of the week
FUNCTION get_weekday(day, month, year)
    IF NOT is_valid_date(day, month, year) THEN
        RETURN "Invalid date"
    END IF
    doomsday = get_doomsday(year)
    ref_day = doomsday_dates[month - 1][0] // Common year reference
    IF is_leap_year(year) AND month ≤ 2 THEN
        ref_day = doomsday_dates[month - 1][1] // Leap year reference for Jan/Feb
    END IF
    diff = (day - ref_day) MOD 7
    IF diff < 0 THEN
        diff = diff + 7
    END IF
    RETURN weekdays[(doomsday + diff) MOD 7]
END FUNCTION

// Main program to test the algorithm
MAIN
    tests = [(18, 9, 1985), (12, 4, 1861), (25, 12, 2021), (7, 8, 1966)]
    FOR EACH (day, month, year) IN tests
        weekday = get_weekday(day, month, year)
        PRINT month_names[month - 1], " ", day, ", ", year, " is a ", weekday
    END FOR



    Notes

Purpose: Computes the day of the week for a given date using the Doomsday Rule, leveraging the century’s anchor day, year’s doomsday, and a reference doomsday date for each month.
Doomsday Dates: Uses memorable dates (e.g., 4/4, 6/6, 9/5) as in the Wikipedia document. January uses 1/3 (common) or 1/4 (leap); February uses 2/28 (common) or 2/29 (leap).
Day Indexing: Follows Conway’s mnemonic: Noneday (Sunday=0), Oneday (Monday=1), ..., Six-a-day (Saturday=6).
Formula: Implements Conway’s method:

Century anchor: (5 * (c mod 4) + 2) mod 7.
Year doomsday: (anchor + a + b + c) mod 7, where a = floor(y/12), b = y mod 12, c = floor(b/4).
Weekday: (doomsday + (day - ref_day) mod 7) mod 7.


Test Cases:

September 18, 1985: Treblesday (Wednesday)
April 12, 1861: Fiveday (Friday)
December 25, 2021: Six-a-day (Saturday)
August 7, 1966: Noneday (Sunday)


Output Format: "[Month] [Day], [Year] is a [Weekday]" or "Invalid date".
Constraints:

Gregorian calendar, year ≥ 1583 (post-reform).
Validates month (1–12), day (per month/leap year), and year.


Clarity: Uses standard pseudocode conventions (e.g., FLOOR, MOD, array indexing) for easy translation to programming languages like those in the prior artifact (C, C++, Java, etc.).
END MAIN
